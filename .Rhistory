tibble::add_column(group=1, .after='libname') %>%
dplyr::select(libname, group, ypos, xpos, meta:=!!annot[1]),. , by='libname') %>%
dplyr::mutate(meta=paste0('m', meta)) %>%
tibble::column_to_rownames(var='libname')
}
# Run non-spatial models
start_t = Sys.time()
cat(crayon::yellow('Running non-spatial tests...\n'))
non_sp_de = list()
non_sp_models = list()
for(sample_name in samples){
# Create a table with combinations of samples, genes, and annotations to test using parallelization
combo = expand.grid(meta=unique(expr_dfs[[sample_name]][['meta']]),
gene=colnames(expr_dfs[[sample_name]] %>%
dplyr::select(-group, -ypos, -xpos, -meta)),
stringsAsFactors=F) %>%
dplyr::arrange(meta)
# Run models in parallel and get DE results
non_sp_de[[sample_name]] = non_spatial_de(expr_df=expr_dfs[[sample_name]], combo=combo, pval_adj=pval_adj)
# Save models
models_keep = non_sp_de[[sample_name]][[1]] %>%
dplyr::filter(adj_p_val < pval_thr) %>%
dplyr::arrange(adj_p_val) %>%
dplyr::slice_head(prop=sp_topgenes) %>%
dplyr::select(gene, cluster) %>%
tidyr::unite('x', gene, cluster) %>%
unlist() %>%
as.vector()
non_sp_models[[sample_name]] = non_sp_de[[sample_name]][[2]][models_keep]
rm(models_keep) # Clean environment
# Extract DE results and add column with sample ID
non_sp_de[[sample_name]] = non_sp_de[[sample_name]][[1]] %>%
tibble::add_column(sample=sample_name, .before=1)
}
end_t = difftime(Sys.time(), start_t, units='min')
cat(crayon::green(paste0('Non-spatial tests completed (', round(end_t, 2), ' min).\n')))
# Run spatial tests on subset of significant genes
start_t = Sys.time()
if(sp_topgenes > 0){
cat(crayon::yellow('Running spatial tests...\n'))
sp_models = list()
# Run models
for(sample_name in samples){
sp_models[[sample_name]] = spatial_de(expr_df=expr_dfs[[sample_name]], non_sp_mods=non_sp_models[[sample_name]], sp_topgenes=sp_topgenes)
}
}
rm(expr_dfs) # Clean environment
end_t = difftime(Sys.time(), start_t, units='min')
cat(crayon::green(paste0('Spatial tests completed (', round(end_t, 2), ' min).\n')))
View(sp_models$ST_mel2_rep2)
sp_models$ST_mel2_rep2[["CCL21_2"]]
rm(list=ls())
source('../spatialGE/R/STlist.R')
source('../spatialGE/R/STde.R')
source('../spatialGE/R/utils.R')
stlist = readRDS('../test_thrane_stlist_nov2022.RDS')
x=stlist
samples=4
annot=NULL
ws=NULL
ks='dtc'
deepSplit=NULL
topgenes=200
sp_topgenes=0.2
pval_thr=0.05
pval_adj=NULL
# Record time
zero_t = Sys.time()
# Stop function if topgenes and sp_topgenes are not valid
if((round(topgenes, 0) <= 0) | (sp_topgenes < 0 | sp_topgenes > 1)){
stop('topgenes or sp_topgenes do not contain valid values.')
}
# Define which samples to plot
if(is.null(samples)){
samples = names(x@spatial_meta)
} else{
if(is.numeric(samples)){
samples = names(x@spatial_meta)[samples]
}
if(length(grep(paste0(samples, collapse='|'), names(x@spatial_meta))) == 0){
stop('The requested samples are not present in the STlist spatial metadata.')
}
}
# Define columns to plot
if(is.null(annot)){
annot = grep('^stclust_spw', colnames(x@spatial_meta[[1]]), value=T)
if(!is.null(ws)){
if(any(ws == 0)){ # To avoid zero ('0') matching other weights
ws_tmp = ws[ws != 0]
annot_tmp = grep('stclust_spw0_|stclust_spw0$', annot, value=T)
if(length(ws_tmp) > 0){ # In case there are other ws in addition to '0'
annot = c(annot_tmp,
grep(paste0('stclust_spw', ws_tmp, collapse='|'), annot, value=T))
} else{
annot = annot_tmp
}
rm(ws_tmp, annot_tmp)
} else{
annot = grep(paste0('stclust_spw', ws, collapse='|'), annot, value=T)
}
}
if(ks[1] != 'dtc'){
annot = grep(paste0('_k', ks,'$', collapse='|'), annot, value=T)
} else if(ks[1] == 'dtc'){
if(!is.null(deepSplit)){
annot = grep(paste0('_dspl', deepSplit, '$', collapse='|'), annot, value=T)
} else{
annot = grep('_dspl', annot, value=T)
}
} else{
stop('Specify one or several k values to test, or use ks=\'dtc\' (default).')
}
}
# Check that the meta data column exists
if(length(grep(paste0('^', annot, '$', collapse='|'),  colnames(x@spatial_meta[[1]]))) == 0){
stop('No metadata column or clustering parameters were specified. Or specified parameters do not exist in metadata.')
} else if(length(grep(paste0('^', annot, '$', collapse='|'),  colnames(x@spatial_meta[[1]]))) > 1){
stop('Only one clustering solution or metadata column can be tested at a time.')
}
# Calculate standardized variance for all samples (regardless if sample is not in requested test)
for(i in 1:length(x@tr_counts)){
# Check that vst is not already calculated
if(length(grep('vst.variance.standardized', colnames(x@gene_meta[[i]]))) == 0){
x@gene_meta[[i]] = Seurat::FindVariableFeatures(x@counts[[i]], verbose=F) %>%
tibble::rownames_to_column(var='gene') %>%
dplyr::select('gene', 'vst.variance.standardized') %>%
dplyr::left_join(x@gene_meta[[i]], ., by='gene')
}
}
# Get top variable genes
genes = list()
for(sample_name in samples){
genes[[sample_name]] = append(genes[[sample_name]],
x@gene_meta[[sample_name]] %>%
dplyr::arrange(desc(vst.variance.standardized)) %>%
dplyr::slice_head(n=topgenes) %>%
dplyr::select(gene) %>%
unlist() %>%
as.vector()
)
}
rm(topgenes) # Clean environment
# Print metadata assignment to be tested
if(grepl('stclust_', annot[1])){
spw_print = stringr::str_extract(annot[1], '(?<=spw)0\\.[0-9]+')
if(grepl('_dspl', annot[1])){
cut_print = stringr::str_extract(annot[1], '(?<=_dspl)[0-9]') %>% paste0('dtc deepSplit=', ., ')...')
} else{
cut_print = stringr::str_extract(annot[1], '(?<=_k)[0-9]') %>% paste0('k=', ., ')...')
}
test_print = paste0('Testing STclust assignment (w=', spw_print, ', ', cut_print)
rm(spw_print, cut_print) # Clean environment
} else{
test_print = paste0('Testing metadata: ', annot[1], '...')
}
cat(crayon::yellow(paste0(test_print, '\n')))
rm(test_print) # Clean environment
# Create data frames for each sample with expression and coordinate data
expr_dfs = list()
for(sample_name in samples){
# Add group dummy column and select relevant columns
# Add character to annotation column that it's treated a factor in case it's an integer
expr_dfs[[sample_name]] = x@tr_counts[[sample_name]] %>%
expandSparse() %>%
tibble::rownames_to_column(var='gene') %>%
dplyr::filter(gene %in% genes[[sample_name]]) %>%
tibble::column_to_rownames(var='gene') %>%
t() %>%
as.data.frame() %>%
tibble::rownames_to_column(var='libname') %>%
dplyr::right_join(x@spatial_meta[[sample_name]] %>%
tibble::add_column(group=1, .after='libname') %>%
dplyr::select(libname, group, ypos, xpos, meta:=!!annot[1]),. , by='libname') %>%
dplyr::mutate(meta=paste0('m', meta)) %>%
tibble::column_to_rownames(var='libname')
}
# Run non-spatial models
start_t = Sys.time()
cat(crayon::yellow('Running non-spatial tests...\n'))
non_sp_de = list()
non_sp_models = list()
for(sample_name in samples){
# Create a table with combinations of samples, genes, and annotations to test using parallelization
combo = expand.grid(meta=unique(expr_dfs[[sample_name]][['meta']]),
gene=colnames(expr_dfs[[sample_name]] %>%
dplyr::select(-group, -ypos, -xpos, -meta)),
stringsAsFactors=F) %>%
dplyr::arrange(meta)
# Run models in parallel and get DE results
non_sp_de[[sample_name]] = non_spatial_de(expr_df=expr_dfs[[sample_name]], combo=combo, pval_adj=pval_adj)
# Save models
models_keep = non_sp_de[[sample_name]][[1]] %>%
dplyr::filter(adj_p_val < pval_thr) %>%
dplyr::arrange(adj_p_val) %>%
dplyr::slice_head(prop=sp_topgenes) %>%
dplyr::select(gene, cluster) %>%
tidyr::unite('x', gene, cluster) %>%
unlist() %>%
as.vector()
non_sp_models[[sample_name]] = non_sp_de[[sample_name]][[2]][models_keep]
rm(models_keep) # Clean environment
# Extract DE results and add column with sample ID
non_sp_de[[sample_name]] = non_sp_de[[sample_name]][[1]] %>%
tibble::add_column(sample=sample_name, .before=1)
}
end_t = difftime(Sys.time(), start_t, units='min')
cat(crayon::green(paste0('Non-spatial tests completed (', round(end_t, 2), ' min).\n')))
# Run spatial tests on subset of significant genes
start_t = Sys.time()
if(sp_topgenes > 0){
cat(crayon::yellow('Running spatial tests...\n'))
sp_models = list()
# Run models
for(sample_name in samples){
sp_models[[sample_name]] = spatial_de(expr_df=expr_dfs[[sample_name]], non_sp_mods=non_sp_models[[sample_name]], sp_topgenes=sp_topgenes)
}
}
sp_models)Ã¥View()
View(sp_models)
expr_df=expr_dfs$ST_mel2_rep2
non_sp_mods=non_sp_models$ST_mel2_rep2
# Paralellize lme models
cores = count_cores(length(non_sp_mods))
names(non_sp_mods)
i=names(non_sp_mods)[1]
i
res_ls = list() # Initiates list to storage results
# Extract cluster and gene identifiers
meta_tmp = rownames(summary(non_sp_mods[[i]])[['tTable']])[2] %>%
gsub('metam', '', .)
gene_tmp = i %>%
gsub(paste0('_', meta_tmp), '', .)
# Workaround to avoid dashes in gene names as nlme does not handle well
genenodash_tmp = gsub('\\-', '_', gene_tmp)
expr_tmp = expr_df %>%
dplyr::select(group, ypos, xpos, meta, !!gene_tmp) %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != paste0('m', meta_tmp) ~ 'other',
TRUE ~ meta), levels=c('other', paste0('m', meta_tmp))))
colnames(expr_tmp) = gsub('\\-', '_', colnames(expr_tmp))
head(expr_tmp)
# Rewrite the lme command call so that it works on the new environment
non_sp_mods[[i]][['call']] = str2lang('nlme::lme.formula(fixed = as.formula(paste0("`", genenodash_tmp, "`", "~meta")), data = expr_tmp, random = ~1 | group, method = "REML")')
tryCatch({
update(non_sp_mods[[i]], correlation=nlme::corSpher(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
})
test=tryCatch({
update(non_sp_mods[[i]], correlation=nlme::corSpher(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
})
head(test$data)
class(sph_out)
class(test)
cores = count_cores(length(non_sp_mods))
#  sp_mods = parallel::mclapply(names(non_sp_mods), function(i){
for(i in names(non_sp_mods)){
res_ls = list() # Initiates list to storage results
# Extract cluster and gene identifiers
meta_tmp = rownames(summary(non_sp_mods[[i]])[['tTable']])[2] %>%
gsub('metam', '', .)
gene_tmp = i %>%
gsub(paste0('_', meta_tmp), '', .)
# Workaround to avoid dashes in gene names as nlme does not handle well
genenodash_tmp = gsub('\\-', '_', gene_tmp)
expr_tmp = expr_df %>%
dplyr::select(group, ypos, xpos, meta, !!gene_tmp) %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != paste0('m', meta_tmp) ~ 'other',
TRUE ~ meta), levels=c('other', paste0('m', meta_tmp))))
colnames(expr_tmp) = gsub('\\-', '_', colnames(expr_tmp))
# Rewrite the lme command call so that it works on the new environment
non_sp_mods[[i]][['call']] = str2lang('nlme::lme.formula(fixed = as.formula(paste0("`", genenodash_tmp, "`", "~meta")), data = expr_tmp, random = ~1 | group, method = "REML")')
# Run spatial models
sph_out = tryCatch({
update(non_sp_mods[[i]], correlation=nlme::corSpher(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
})
if(class(sph_out) == 'try-error'){
res_ls[['sph']] = 'no_conv'
} else{
res_ls[['sph']] = sph_out
}
exp_out = tryCatch({
update(non_sp_mods[[i]], correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
})
if(class(exp_out) == 'try-error'){
res_ls[['exp']] = 'no_conv'
} else{
res_ls[['exp']] = exp_out
}
#
#     res_ls[['sph']] = update(non_sp_mods[[i]], correlation=nlme::corSpher(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=T, msVerbose=T, gradHess=-F))
#     res_ls[['exp']] = update(non_sp_mods[[i]], correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=T, msVerbose=T, gradHess=F))
}
res_ls
i
update(non_sp_mods[[i]], correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
tryCatch({
update(non_sp_mods[[i]], correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
})
test== tryCatch({
update(non_sp_mods[[i]], correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
})
test= tryCatch({
update(non_sp_mods[[i]], correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
})
test
head(test$data)
test=tryCatch({
update(non_sp_mods[[i]], correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
}, error='no_conv')
test
head(non_sp_mods[[i]]$data)
test=tryCatch({
update(non_sp_mods[[i]], correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
}, error=function(){return('no_conv')})
i
test=tryCatch({
update(non_sp_mods[[i]], correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
}, error=function(err){return(err)})
test
class(test)
??simpleError
rm(list=ls())
source('../spatialGE/R/STlist.R')
source('../spatialGE/R/STde.R')
source('../spatialGE/R/utils.R')
stlist = readRDS('../test_thrane_stlist_nov2022.RDS')
x=stlist
samples=4
annot=NULL
ws=NULL
ks='dtc'
deepSplit=NULL
topgenes=200
sp_topgenes=0.2
pval_thr=0.05
pval_adj=NULL
# Record time
zero_t = Sys.time()
# Stop function if topgenes and sp_topgenes are not valid
if((round(topgenes, 0) <= 0) | (sp_topgenes < 0 | sp_topgenes > 1)){
stop('topgenes or sp_topgenes do not contain valid values.')
}
# Define which samples to plot
if(is.null(samples)){
samples = names(x@spatial_meta)
} else{
if(is.numeric(samples)){
samples = names(x@spatial_meta)[samples]
}
if(length(grep(paste0(samples, collapse='|'), names(x@spatial_meta))) == 0){
stop('The requested samples are not present in the STlist spatial metadata.')
}
}
# Define columns to plot
if(is.null(annot)){
annot = grep('^stclust_spw', colnames(x@spatial_meta[[1]]), value=T)
if(!is.null(ws)){
if(any(ws == 0)){ # To avoid zero ('0') matching other weights
ws_tmp = ws[ws != 0]
annot_tmp = grep('stclust_spw0_|stclust_spw0$', annot, value=T)
if(length(ws_tmp) > 0){ # In case there are other ws in addition to '0'
annot = c(annot_tmp,
grep(paste0('stclust_spw', ws_tmp, collapse='|'), annot, value=T))
} else{
annot = annot_tmp
}
rm(ws_tmp, annot_tmp)
} else{
annot = grep(paste0('stclust_spw', ws, collapse='|'), annot, value=T)
}
}
if(ks[1] != 'dtc'){
annot = grep(paste0('_k', ks,'$', collapse='|'), annot, value=T)
} else if(ks[1] == 'dtc'){
if(!is.null(deepSplit)){
annot = grep(paste0('_dspl', deepSplit, '$', collapse='|'), annot, value=T)
} else{
annot = grep('_dspl', annot, value=T)
}
} else{
stop('Specify one or several k values to test, or use ks=\'dtc\' (default).')
}
}
# Check that the meta data column exists
if(length(grep(paste0('^', annot, '$', collapse='|'),  colnames(x@spatial_meta[[1]]))) == 0){
stop('No metadata column or clustering parameters were specified. Or specified parameters do not exist in metadata.')
} else if(length(grep(paste0('^', annot, '$', collapse='|'),  colnames(x@spatial_meta[[1]]))) > 1){
stop('Only one clustering solution or metadata column can be tested at a time.')
}
# Calculate standardized variance for all samples (regardless if sample is not in requested test)
for(i in 1:length(x@tr_counts)){
# Check that vst is not already calculated
if(length(grep('vst.variance.standardized', colnames(x@gene_meta[[i]]))) == 0){
x@gene_meta[[i]] = Seurat::FindVariableFeatures(x@counts[[i]], verbose=F) %>%
tibble::rownames_to_column(var='gene') %>%
dplyr::select('gene', 'vst.variance.standardized') %>%
dplyr::left_join(x@gene_meta[[i]], ., by='gene')
}
}
# Get top variable genes
genes = list()
for(sample_name in samples){
genes[[sample_name]] = append(genes[[sample_name]],
x@gene_meta[[sample_name]] %>%
dplyr::arrange(desc(vst.variance.standardized)) %>%
dplyr::slice_head(n=topgenes) %>%
dplyr::select(gene) %>%
unlist() %>%
as.vector()
)
}
rm(topgenes) # Clean environment
# Print metadata assignment to be tested
if(grepl('stclust_', annot[1])){
spw_print = stringr::str_extract(annot[1], '(?<=spw)0\\.[0-9]+')
if(grepl('_dspl', annot[1])){
cut_print = stringr::str_extract(annot[1], '(?<=_dspl)[0-9]') %>% paste0('dtc deepSplit=', ., ')...')
} else{
cut_print = stringr::str_extract(annot[1], '(?<=_k)[0-9]') %>% paste0('k=', ., ')...')
}
test_print = paste0('Testing STclust assignment (w=', spw_print, ', ', cut_print)
rm(spw_print, cut_print) # Clean environment
} else{
test_print = paste0('Testing metadata: ', annot[1], '...')
}
cat(crayon::yellow(paste0(test_print, '\n')))
rm(test_print) # Clean environment
# Create data frames for each sample with expression and coordinate data
expr_dfs = list()
for(sample_name in samples){
# Add group dummy column and select relevant columns
# Add character to annotation column that it's treated a factor in case it's an integer
expr_dfs[[sample_name]] = x@tr_counts[[sample_name]] %>%
expandSparse() %>%
tibble::rownames_to_column(var='gene') %>%
dplyr::filter(gene %in% genes[[sample_name]]) %>%
tibble::column_to_rownames(var='gene') %>%
t() %>%
as.data.frame() %>%
tibble::rownames_to_column(var='libname') %>%
dplyr::right_join(x@spatial_meta[[sample_name]] %>%
tibble::add_column(group=1, .after='libname') %>%
dplyr::select(libname, group, ypos, xpos, meta:=!!annot[1]),. , by='libname') %>%
dplyr::mutate(meta=paste0('m', meta)) %>%
tibble::column_to_rownames(var='libname')
}
# Run non-spatial models
start_t = Sys.time()
cat(crayon::yellow('Running non-spatial tests...\n'))
non_sp_de = list()
non_sp_models = list()
for(sample_name in samples){
# Create a table with combinations of samples, genes, and annotations to test using parallelization
combo = expand.grid(meta=unique(expr_dfs[[sample_name]][['meta']]),
gene=colnames(expr_dfs[[sample_name]] %>%
dplyr::select(-group, -ypos, -xpos, -meta)),
stringsAsFactors=F) %>%
dplyr::arrange(meta)
# Run models in parallel and get DE results
non_sp_de[[sample_name]] = non_spatial_de(expr_df=expr_dfs[[sample_name]], combo=combo, pval_adj=pval_adj)
# Save models
models_keep = non_sp_de[[sample_name]][[1]] %>%
dplyr::filter(adj_p_val < pval_thr) %>%
dplyr::arrange(adj_p_val) %>%
dplyr::slice_head(prop=sp_topgenes) %>%
dplyr::select(gene, cluster) %>%
tidyr::unite('x', gene, cluster) %>%
unlist() %>%
as.vector()
non_sp_models[[sample_name]] = non_sp_de[[sample_name]][[2]][models_keep]
rm(models_keep) # Clean environment
# Extract DE results and add column with sample ID
non_sp_de[[sample_name]] = non_sp_de[[sample_name]][[1]] %>%
tibble::add_column(sample=sample_name, .before=1)
}
end_t = difftime(Sys.time(), start_t, units='min')
cat(crayon::green(paste0('Non-spatial tests completed (', round(end_t, 2), ' min).\n')))
# Run spatial tests on subset of significant genes
start_t = Sys.time()
if(sp_topgenes > 0){
cat(crayon::yellow('Running spatial tests...\n'))
sp_models = list()
# Run models
for(sample_name in samples){
sp_models[[sample_name]] = spatial_de(expr_df=expr_dfs[[sample_name]], non_sp_mods=non_sp_models[[sample_name]], sp_topgenes=sp_topgenes)
}
}
View(sp_models)
sp_models[["ST_mel2_rep2"]][["TMSB4X_1"]]$exp
supdate(non_sp_models$ST_mel2_rep2$CORO1A_2, correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
update(non_sp_models$ST_mel2_rep2$CORO1A_2, correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
non_sp_models$ST_mel2_rep2$CORO1A_2[['call']] = str2lang('nlme::lme.formula(fixed = as.formula(paste0("`", genenodash_tmp, "`", "~meta")), data = expr_tmp, random = ~1 | group, method = "REML")')
update(non_sp_models$ST_mel2_rep2$CORO1A_2, correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
i='CORO1A_2'
meta_tmp = rownames(summary(non_sp_mods[[i]])[['tTable']])[2] %>%
gsub('metam', '', .)
non_sp_mods=non_sp_models$ST_mel2_rep2
expr_df=expr_dfs$ST_mel2_rep2
# Extract cluster and gene identifiers
meta_tmp = rownames(summary(non_sp_mods[[i]])[['tTable']])[2] %>%
gsub('metam', '', .)
gene_tmp = i %>%
gsub(paste0('_', meta_tmp), '', .)
# Workaround to avoid dashes in gene names as nlme does not handle well
genenodash_tmp = gsub('\\-', '_', gene_tmp)
expr_tmp = expr_df %>%
dplyr::select(group, ypos, xpos, meta, !!gene_tmp) %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != paste0('m', meta_tmp) ~ 'other',
TRUE ~ meta), levels=c('other', paste0('m', meta_tmp))))
colnames(expr_tmp) = gsub('\\-', '_', colnames(expr_tmp))
# Rewrite the lme command call so that it works on the new environment
non_sp_mods[[i]][['call']] = str2lang('nlme::lme.formula(fixed = as.formula(paste0("`", genenodash_tmp, "`", "~meta")), data = expr_tmp, random = ~1 | group, method = "REML")')
update(non_sp_mods[[i]], correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=F))
update(non_sp_mods[[i]], correlation=nlme::corExp(form=~xpos+ypos, nugget=T, metric='euclidean'), method='REML', control=nlme::lmeControl(returnObject=F, msVerbose=F, gradHess=T))
