} else{
annot = annot_tmp
}
rm(ws_tmp, annot_tmp)
} else{
annot = grep(paste0('stclust_spw', ws, collapse='|'), annot, value=T)
}
}
if(ks[1] != 'dtc'){
annot = grep(paste0('_k', ks,'$', collapse='|'), annot, value=T)
} else if(ks[1] == 'dtc'){
if(!is.null(deepSplit)){
annot = grep(paste0('_dspl', deepSplit, '$', collapse='|'), annot, value=T)
} else{
annot = grep('_dspl', annot, value=T)
}
} else{
stop('Specify one or several k values to test, or use ks=\'dtc\' (default).')
}
}
ws=NULL
# Define columns to plot
if(is.null(annot)){
annot = grep('^stclust_spw', colnames(x@spatial_meta[[1]]), value=T)
if(!is.null(ws)){
if(any(ws == 0)){ # To avoid zero ('0') matching other weights
ws_tmp = ws[ws != 0]
annot_tmp = grep('stclust_spw0_|stclust_spw0$', annot, value=T)
if(length(ws_tmp) > 0){ # In case there are other ws in addition to '0'
annot = c(annot_tmp,
grep(paste0('stclust_spw', ws_tmp, collapse='|'), annot, value=T))
} else{
annot = annot_tmp
}
rm(ws_tmp, annot_tmp)
} else{
annot = grep(paste0('stclust_spw', ws, collapse='|'), annot, value=T)
}
}
if(ks[1] != 'dtc'){
annot = grep(paste0('_k', ks,'$', collapse='|'), annot, value=T)
} else if(ks[1] == 'dtc'){
if(!is.null(deepSplit)){
annot = grep(paste0('_dspl', deepSplit, '$', collapse='|'), annot, value=T)
} else{
annot = grep('_dspl', annot, value=T)
}
} else{
stop('Specify one or several k values to test, or use ks=\'dtc\' (default).')
}
}
annot
# Check that the meta data column exists
if(length(grep(paste0('^', annot, '$', collapse='|'),  colnames(x@spatial_meta[[1]]))) == 0){
stop('No metadata column or clustering parameters were specified. Or specified parameters do not exist in metadata.')
} else if(length(grep(paste0('^', annot, '$', collapse='|'),  colnames(x@spatial_meta[[1]]))) > 1){
stop('Only one clustering solution or metadata column can be tested at a time.')
}
# Calculate standardized variance for all samples (regardless if sample is not in requested test)
for(i in 1:length(x@tr_counts)){
# Check that vst is not already calculated
if(length(grep('vst.variance.standardized', colnames(x@gene_meta[[i]]))) == 0){
x@gene_meta[[i]] = Seurat::FindVariableFeatures(x@counts[[i]], verbose=F) %>%
tibble::rownames_to_column(var='gene') %>%
dplyr::select('gene', 'vst.variance.standardized') %>%
dplyr::left_join(x@gene_meta[[i]], ., by='gene')
}
}
if(is.null(genes)){
# Get top variable genes
genes = c()
for(i in samples){
genes = append(genes,
x@gene_meta[[i]] %>%
dplyr::arrange(desc(vst.variance.standardized)) %>%
dplyr::slice_head(n=topgenes) %>%
dplyr::select(gene) %>%
unlist() %>%
as.vector()
)
}
genes = unique(genes)
rm(topgenes) # Clean environment
}
# Create data frames for each sample with expression and coordinate data
expr_dfs = list()
for(i in samples){
# Add group dummy column and select relevant columns
# Add character to annotation column that it's treated a factor in case it's an integer
expr_dfs[[i]] = x@tr_counts[[i]] %>%
expandSparse() %>%
tibble::rownames_to_column(var='gene') %>%
dplyr::filter(gene %in% genes) %>%
tibble::column_to_rownames(var='gene') %>%
t() %>%
as.data.frame() %>%
tibble::rownames_to_column(var='libname') %>%
dplyr::right_join(x@spatial_meta[[i]] %>%
tibble::add_column(group=1, .after='libname') %>%
dplyr::select(libname, group, ypos, xpos, meta:=!!annot[1]),. , by='libname') %>%
dplyr::mutate(meta=paste0('m', meta)) %>%
tibble::column_to_rownames(var='libname')
}
# Print metadata assignment to be tested
if(grepl('stclust_', annot[1])){
spw_print = stringr::str_extract(annot[1], '(?<=spw)0\\.[0-9]+')
if(grepl('_dspl', annot[1])){
cut_print = stringr::str_extract(annot[1], '(?<=_dspl)[0-9]') %>% paste0('dtc deepSplit=', ., ')...')
} else{
cut_print = stringr::str_extract(annot[1], '(?<=_k)[0-9]') %>% paste0('k=', ., ')...')
}
test_print = paste0('Testing STclust assignment (w=', spw_print, ', ', cut_print)
rm(spw_print, cut_print) # Clean environment
} else{
test_print = paste0('Testing metadata: ', annot[1], '...')
}
cat(crayon::yellow(test_print))
rm(test_print) # Clean environment
# Create a table with combinations of samples, genes, and annotations to test using parallelization
combo = tibble::tibble()
combo
for(i in samples){
combo = dplyr::bind_rows(combo,
dplyr::bind_cols(tibble::tibble(sample=i),
expand.grid(meta=unique(expr_dfs[[i]][['meta']]),
gene=colnames(expr_dfs[[i]] %>% dplyr::select(-group, -ypos, -xpos, -meta)))))
}
combo
# Run non spatial models
cat(crayon::yellow('Running non-spatial tests...'))
cores = count_cores(nrow(combo))
i=1
sample_name = as.vector(unlist(combo[i, 1]))
meta_tmp = as.vector(unlist(combo[i, 2]))
gene_tmp = as.vector(unlist(combo[i, 3]))
sample_name
meta_tmp
gene_tmp
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
df_tmp
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
lm_mod
res_df = tibble::tibble(sample=sample_name,
gene=gene_tmp,
cluster=gsub('metam', '', rownames(summary(lm_mod)[['tTable']])[2]),
p_val=summary(lm_mod)[['tTable']][2, 5])
res_df
plot_spatial(x, samples = 1, genes='ISG15')
names(x@counts)
sample_name="sample8_LMM_B3"
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
lm_mod
sample_name = "151670"
meta_tmp = as.vector(unlist(combo[i, 2]))
gene_tmp = as.vector(unlist(combo[i, 3]))
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
lm_mod
# Run non spatial models
cat(crayon::yellow('Running non-spatial tests...'))
cores = count_cores(nrow(combo))
result_ls = parallel::mclapply(seq_along(1:nrow(combo)), function(i){
sample_name = as.vector(unlist(combo[i, 1]))
meta_tmp = as.vector(unlist(combo[i, 2]))
gene_tmp = as.vector(unlist(combo[i, 3]))
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
# Create non-spatial model
#lm_mod = nlme::lme(fixed=as.formula(paste0(gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
# res_df = tibble::tibble(sample=sample_name,
#                         gene=gene_tmp,
#                         cluster=gsub('metam', '', rownames(summary(lm_mod)[['tTable']])[2]),
#                         p_val=summary(lm_mod)[['tTable']][2, 5])
#return(res_df)
return(df_tmp)
}, mc.cores=cores)
result_ls[[1]]
result_ls[[2]]
View(result_ls)
combo = combo[1:10, ]
result_ls = parallel::mclapply(seq_along(1:nrow(combo)), function(i){
sample_name = as.vector(unlist(combo[i, 1]))
meta_tmp = as.vector(unlist(combo[i, 2]))
gene_tmp = as.vector(unlist(combo[i, 3]))
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
# Create non-spatial model
#lm_mod = nlme::lme(fixed=as.formula(paste0(gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
# res_df = tibble::tibble(sample=sample_name,
#                         gene=gene_tmp,
#                         cluster=gsub('metam', '', rownames(summary(lm_mod)[['tTable']])[2]),
#                         p_val=summary(lm_mod)[['tTable']][2, 5])
#return(res_df)
return(df_tmp)
}, mc.cores=cores)
View(result_ls)
result_ls[[1]]
result_ls = parallel::mclapply(seq_along(1:nrow(combo)), function(i){
sample_name = as.vector(unlist(combo[i, 1]))
meta_tmp = as.vector(unlist(combo[i, 2]))
gene_tmp = as.vector(unlist(combo[i, 3]))
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
# res_df = tibble::tibble(sample=sample_name,
#                         gene=gene_tmp,
#                         cluster=gsub('metam', '', rownames(summary(lm_mod)[['tTable']])[2]),
#                         p_val=summary(lm_mod)[['tTable']][2, 5])
#return(res_df)
return(lm_mod)
}, mc.cores=cores)
View(result_ls)
result_ls[[1]]
# Create a table with combinations of samples, genes, and annotations to test using parallelization
combo = tibble::tibble()
for(i in samples){
combo = dplyr::bind_rows(combo,
dplyr::bind_cols(tibble::tibble(sample=i),
expand.grid(meta=unique(expr_dfs[[i]][['meta']]),
gene=colnames(expr_dfs[[i]] %>% dplyr::select(-group, -ypos, -xpos, -meta)))))
}
combo
combo=combo[c(1:10, 8000:8020), ]
combo
result_ls = parallel::mclapply(seq_along(1:nrow(combo)), function(i){
sample_name = as.vector(unlist(combo[i, 1]))
meta_tmp = as.vector(unlist(combo[i, 2]))
gene_tmp = as.vector(unlist(combo[i, 3]))
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
# res_df = tibble::tibble(sample=sample_name,
#                         gene=gene_tmp,
#                         cluster=gsub('metam', '', rownames(summary(lm_mod)[['tTable']])[2]),
#                         p_val=summary(lm_mod)[['tTable']][2, 5])
#return(res_df)
return(lm_mod)
}, mc.cores=cores)
View(result_ls)
result_ls[[25]]
result_ls = parallel::mclapply(seq_along(1:nrow(combo)), function(i){
sample_name = as.vector(unlist(combo[i, 1]))
meta_tmp = as.vector(unlist(combo[i, 2]))
gene_tmp = as.vector(unlist(combo[i, 3]))
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
res_df = tibble::tibble(sample=sample_name,
gene=gene_tmp,
cluster=gsub('metam', '', rownames(summary(lm_mod)[['tTable']])[2]),
p_val=summary(lm_mod)[['tTable']][2, 5])
return(res_df)
#return(lm_mod)
}, mc.cores=cores)
View(result_ls)
result_ls[[6]]
result_ls[[24]]
plot_spatial(x, deepSplit = 2)
plot_spatial(x, deepSplit = 2, sample=1)
result_ls[[24]]
result_ls[[6]]
plot_spatial(x, samples = 1, genes='ISG15')
View(expr_dfs)
expr_dfs[["151675"]]
# Create a table with combinations of samples, genes, and annotations to test using parallelization
combo = tibble::tibble()
for(i in samples){
combo = dplyr::bind_rows(combo,
dplyr::bind_cols(tibble::tibble(sample=i),
expand.grid(meta=unique(expr_dfs[[i]][['meta']]),
gene=colnames(expr_dfs[[i]] %>% dplyr::select(-group, -ypos, -xpos, -meta)))))
}
names(x@counts)
dim(combo[combo$sample == 'sample1_MB14_A', ])
dim(combo[combo$sample == '151670', ])
dim(combo[combo$sample == '151670' & combo$meta == 'm1', ])
dim(combo[combo$sample == 'sample1_MB14_A' & combo$meta == 'm1', ])
combo
for(i in 1:nrow(combo)){
sample_name = as.vector(unlist(combo[i, 1]))
meta_tmp = as.vector(unlist(combo[i, 2]))
gene_tmp = as.vector(unlist(combo[i, 3]))
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
res_df = tibble::tibble(sample=sample_name,
gene=gene_tmp,
cluster=gsub('metam', '', rownames(summary(lm_mod)[['tTable']])[2]),
p_val=summary(lm_mod)[['tTable']][2, 5])
#return(res_df)
}
gene_tmp
sample_name
combo[i, ]
res_df
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
df_tmp
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
gene_tmp
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(`gene_tmp`, '~meta')), data=df_tmp, random=~1|group, method='REML')
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(!!gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(!!!gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(!gene_tmp, '~meta')), data=df_tmp, random=~1|group, method='REML')
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(as.character(gene_tmp), '~meta')), data=df_tmp, random=~1|group, method='REML')
paste0(!!!gene_tmp, '~meta')
paste0(!!gene_tmp, '~meta')
paste0(gene_tmp, '~meta')
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0('`', gene_tmp, '`', '~meta')), data=df_tmp, random=~1|group, method='REML')
paste0('`', gene_tmp, '`', '~meta')
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0("'", gene_tmp, "'", '~meta')), data=df_tmp, random=~1|group, method='REML')
paste0("'", gene_tmp, "'", '~meta')
paste0("`", gene_tmp, "`", '~meta')
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0("`", gene_tmp, "`", '~meta')), data=df_tmp, random=~1|group, method='REML')
paste0(gene_tmp, '~meta')
as.formula(paste0("`", gene_tmp, "`", '~meta'))
df_tmp
gene_tmp %in% colnames(df_tmp)
as.formula(paste0("`", gene_tmp, "`", '~meta'))
nlme::lme(fixed=as.formula(paste0("`", gene_tmp, "`", '~meta')), data=df_tmp, random=~1|group, method='REML')
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0("\\'", gene_tmp, "\\'", '~meta')), data=df_tmp, random=~1|group, method='REML')
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0("'", gene_tmp, "'", '~meta')), data=df_tmp, random=~1|group, method='REML')
as.formula(paste0("'", gene_tmp, "'", '~meta'))
nlme::lme(fixed=as.formula(paste0("'", gene_tmp, "'", '~meta')), data=df_tmp, random=~1|group, method='REML')
as.formula(paste("y~", paste0("`", "x-1", "`")))
as.formula(paste0("`", gene_tmp, "`", '~meta'))
nlme::lme(fixed=as.formula(paste("meta~", paste0("`", "x-1", "`"))), data=df_tmp, random=~1|group, method='REML')
as.formula(paste0("`", gene_tmp, "`", '~meta'))
nlme::lme(fixed=as.formula(paste0("`", gene_tmp, "`", '~meta')), data=df_tmp, random=~1|group, method='REML')
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0('meta~', "`", gene_tmp, "`")), data=df_tmp, random=~1|group, method='REML')
as.formula(paste0('meta~', "`", gene_tmp, "`"))
nlme::lme(fixed=as.formula(paste0('meta~', "`", gene_tmp, "`")), data=df_tmp, random=~1|group, method='REML')
colnames(df_tmp)
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::select(group, meta, !!gene_tmp) %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
df_tmp
head(df_tmp)
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0("`", gene_tmp, "`", '~meta')), data=df_tmp, random=~1|group, method='REML')
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0(".~meta")), data=df_tmp, random=~1|group, method='REML')
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0("meta~.")), data=df_tmp, random=~1|group, method='REML')
gene_tmp='ID3'
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::select(group, meta, !!gene_tmp) %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
head(df_tmp)
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0("meta~.")), data=df_tmp, random=~1|group, method='REML')
# Create non-spatial model
lm_mod = nlme::lme(fixed=meta~., data=df_tmp, random=~1|group, method='REML')
gene_tmp = as.vector(unlist(combo[i, 3]))
gene_tmp
genenodash_tmp = gsub('\\-', '_', gene_tmp)
genenodash_tmp
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::select(group, meta, genenodash_tmp=!!gene_tmp) %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
df_tmp
head(df_tmp)
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::select(group, meta, genenodash_tmp:=!!gene_tmp) %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
head(df_tmp)
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::select(group, meta, genenodash_tmp:=gene_tmp) %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
sample_name = as.vector(unlist(combo[i, 1]))
meta_tmp = as.vector(unlist(combo[i, 2]))
gene_tmp = as.vector(unlist(combo[i, 3]))
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::select(group, meta, !!gene_tmp) %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
# Workaround to avoid dahs in gene names as nlme does not handle well
genenodash_tmp = gsub('\\-', '_', gene_tmp)
colnames(df_tmp) = gsub('\\-', '_', colnames(df_tmp))
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0("`", genenodash_tmp, "`", '~meta')), data=df_tmp, random=~1|group, method='REML')
lm_mod
res_df = tibble::tibble(sample=sample_name,
gene=gene_tmp,
cluster=gsub('metam', '', rownames(summary(lm_mod)[['tTable']])[2]),
p_val=summary(lm_mod)[['tTable']][2, 5])
res_df
plot_spatial(x, gene='LHFPL3-AS1', sample=1)
meta_tmp
meta_tmp = 'm6'
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::select(group, meta, !!gene_tmp) %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
head(df_tmp)
unique(df_tmp$meta)
# Workaround to avoid dahs in gene names as nlme does not handle well
genenodash_tmp = gsub('\\-', '_', gene_tmp)
colnames(df_tmp) = gsub('\\-', '_', colnames(df_tmp))
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0("`", genenodash_tmp, "`", '~meta')), data=df_tmp, random=~1|group, method='REML')
res_df = tibble::tibble(sample=sample_name,
gene=gene_tmp,
cluster=gsub('metam', '', rownames(summary(lm_mod)[['tTable']])[2]),
p_val=summary(lm_mod)[['tTable']][2, 5])
res_df
plot_spatial(x, gene='LHFPL3-AS1', sample=1)
plot_spatial(x, gene='LHFPL3-AS1', sample=1, ptsize = 2)
result_ls = parallel::mclapply(seq_along(1:nrow(combo)), function(i){
sample_name = as.vector(unlist(combo[i, 1]))
meta_tmp = as.vector(unlist(combo[i, 2]))
gene_tmp = as.vector(unlist(combo[i, 3]))
df_tmp = expr_dfs[[sample_name]] %>%
dplyr::select(group, meta, !!gene_tmp) %>%
dplyr::mutate(meta=factor(dplyr::case_when(meta != meta_tmp ~ 'other',
TRUE ~ meta), levels=c('other', meta_tmp)))
# Workaround to avoid dahs in gene names as nlme does not handle well
genenodash_tmp = gsub('\\-', '_', gene_tmp)
colnames(df_tmp) = gsub('\\-', '_', colnames(df_tmp))
# Create non-spatial model
lm_mod = nlme::lme(fixed=as.formula(paste0("`", genenodash_tmp, "`", '~meta')), data=df_tmp, random=~1|group, method='REML')
res_df = tibble::tibble(sample=sample_name,
gene=gene_tmp,
cluster=gsub('metam', '', rownames(summary(lm_mod)[['tTable']])[2]),
p_val=summary(lm_mod)[['tTable']][2, 5])
return(res_df)
}, mc.cores=cores)
View(result_ls)
if(nrow(combo) == length(result_ls)){
names(result_ls) = apply(combo, 1, paste0, collapse='_')
result_ls = do.call(rbind, result_ls)
}
result_ls
any(result_ls$p_val >  0.05)
sum(result_ls$p_val >  0.05)
length(result_ls$p_val)
plot_spatial(x, gene='LHFPL3-AS1', sample=2)
plot_spatial(x, gene='LHFPL3-AS1', sample=2, ptsize = 2)
result_ls[result_ls$gene == 'LHFPL3-AS1', ]
2.93e- 1
2.93e-1
plot_spatial(x, deepSplit = 2, sample=2)
plot_spatial(x, gene='LHFPL3-AS1', sample=2, ptsize = 2)
plot_spatial(x, deepSplit = 2, sample=2)
plot_spatial(x, deepSplit = 2, sample=2, ptsize = 2)
6.66e- 4
6.66e-4
2.93e-1
6.66e-4
require('magrittr')
require('ggplot2')
source('../../spatialGE/R/plot_spatial_expression.R')
source('../../spatialGE/R/plot_spatial_meta.R')
source('../../spatialGE/R/plot_helpers.R')
source('../../spatialGE/R/plot_spatial.R')
source('../..//spatialGE/R/classdefinitions.R')
source('../../spatialGE/R/detect_input.R')
source('../..//spatialGE/R/STlist.R')
source('../../spatialGE/R/import_visium_h5.R')
source('../../spatialGE/R/import_visium.R')
#source('../../spatialGE/R/import_geomx.R')
source('../../spatialGE/R/utils.R')
source('../../spatialGE/R/transform_data.R')
source('../../spatialGE/R/STclust.R')
source('../../spatialGE/R/STde.R')
stlist = readRDS('../../test_thrane_stlist_nov2022.RDS')
plot_spatial(stlist)
stlist = readRDS('../../test_thrane_stlist_nov2022.RDS', VISIUM=F)
stlist = readRDS('../../test_thrane_stlist_nov2022.RDS', visium=F)
stlist = readRDS('../../test_thrane_stlist_nov2022.RDS')
plot_spatial(stlist, visium=F)
plot_spatial(stlist, visium=F, samples = 1)
plot_spatial(stlist, visium=F, samples = 1, ptsize = 2)
plot_spatial(stlist, visium=F, samples = 2, ptsize = 2)
