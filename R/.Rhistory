top_n=10
res=NULL
samples=NULL
python=T
# Universal kriging not implemented for now
univ=F
# geoR implementation of universal kriging to be implemented.
# Probably will allow users to specify parameters from variogram
if(python == F && univ == T){
stop('Currently, universal kriging is only available using Python kriging (PyKrige)')
}
# Test that transformed counts are available
if(rlang::is_empty(x@tr_counts)) {
stop("There are not transformed counts in this STList.")
}
# Test if no specific subject plot was requested.
if (is.null(samples)) {
sample = c(1:length(x@tr_counts))
}
# Test that a gene name was entered.
if(is.null(genes)) {
stop("Please, enter one or more genes to plot.")
}
# If genes='top', get names of 10 genes with the highest standard deviation.
if(length(genes) == 1 && genes == 'top'){
genes = c()
for(i in samples){
# Find tops variable genes using Seurat approach. In the past, instead of Seurat, genes with the highest stdev were used
if(any(colnames(x@gene_meta[[i]]) == 'vst.variance.standardized')){
x@gene_meta[[i]] = x@gene_meta[[i]][, !grepl('vst.variance.standardized', colnames(x@gene_meta[[i]]))]
}
x@gene_meta[[i]] = Seurat::FindVariableFeatures(x@counts[[i]], verbose=F) %>%
tibble::rownames_to_column(var='gene') %>%
dplyr::select('gene', 'vst.variance.standardized') %>%
dplyr::left_join(x@gene_meta[[i]], ., by='gene')
genes = append(genes, x@gene_meta[[i]][['gene']][order(x@gene_meta[[i]][['vst.variance.standardized']], decreasing=T)][1:10])
}
# Get unique genes from most variable.
genes = unique(genes)
}
# Test that a gene name was entered.
if(is.null(genes)) {
stop("Please, enter one or more genes to plot.")
}
x=exampleSTList
genes='top'
top_n=10
res=NULL
samples=NULL
python=T
# Universal kriging not implemented for now
univ=F
# geoR implementation of universal kriging to be implemented.
# Probably will allow users to specify parameters from variogram
if(python == F && univ == T){
stop('Currently, universal kriging is only available using Python kriging (PyKrige)')
}
# Test that transformed counts are available
if(rlang::is_empty(x@tr_counts)) {
stop("There are not transformed counts in this STList.")
}
# Test if no specific subject plot was requested.
if (is.null(samples)) {
sample = c(1:length(x@tr_counts))
}
# Test that a gene name was entered.
if(is.null(genes)) {
stop("Please, enter one or more genes to plot.")
}
length(genes) == 1 && genes == 'top'
i
samples
require('magrittr')
require('ggplot2')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/plot_spatial.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/plot_helpers.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/classDefinitions.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/detect_input.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/STList.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/import_visium_h5.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/import_visium.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/utils.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/transform_data.R')
# Vector with several filepaths tsv, sample names (required).
rna_fp = c('/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel1_rep1_counts.tsv',
'/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel1_rep2_counts.tsv',
'/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel2_rep1_counts.tsv',
'/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel2_rep2_counts.tsv')
coord_fp = c('/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel1_rep1_mapping.tsv',
'/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel1_rep2_mapping.tsv',
'/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel2_rep1_mapping.tsv',
'/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel2_rep2_mapping.tsv')
exampleSTList = STlist(rnacounts=rna_fp, spotcoords=coord_fp, samples=c('ST_mel1_rep1', 'ST_mel1_rep2', 'ST_mel2_rep1', 'ST_mel2_rep2'))
exampleSTList = transform_data(exampleSTList)
x=exampleSTList
genes='top'
top_n=10
res=NULL
samples=NULL
python=T
univ=F
# geoR implementation of universal kriging to be implemented.
# Probably will allow users to specify parameters from variogram
if(python == F && univ == T){
stop('Currently, universal kriging is only available using Python kriging (PyKrige)')
}
# Test that transformed counts are available
if(rlang::is_empty(x@tr_counts)) {
stop("There are not transformed counts in this STList.")
}
# Test if no specific subject plot was requested.
if (is.null(samples)) {
samples = c(1:length(x@tr_counts))
}
# Test that a gene name was entered.
if(is.null(genes)) {
stop("Please, enter one or more genes to plot.")
}
# If genes='top', get names of 10 genes with the highest standard deviation.
if(length(genes) == 1 && genes == 'top'){
genes = c()
for(i in samples){
# Find tops variable genes using Seurat approach. In the past, instead of Seurat, genes with the highest stdev were used
if(any(colnames(x@gene_meta[[i]]) == 'vst.variance.standardized')){
x@gene_meta[[i]] = x@gene_meta[[i]][, !grepl('vst.variance.standardized', colnames(x@gene_meta[[i]]))]
}
x@gene_meta[[i]] = Seurat::FindVariableFeatures(x@counts[[i]], verbose=F) %>%
tibble::rownames_to_column(var='gene') %>%
dplyr::select('gene', 'vst.variance.standardized') %>%
dplyr::left_join(x@gene_meta[[i]], ., by='gene')
genes = append(genes, x@gene_meta[[i]][['gene']][order(x@gene_meta[[i]][['vst.variance.standardized']], decreasing=T)][1:10])
}
# Get unique genes from most variable.
genes = unique(genes)
}
genes
# Test if list with kriging exists for each gene. If not create it.
for(gene in genes){
if(is.null(x@gene_krige[[gene]]) && rlang::is_empty(x@gene_krige[[gene]])){
x@gene_krige[[gene]] = list()
for(i in 1:length(x@tr_counts)){
x@gene_krige[[gene]][[names(x@tr_counts[i])]] = list()
}
}
}
x@gene_krige$CCL21$ST_mel1_rep1
# Store kriging type.
if(univ){
x@misc[['gene_krige_type']] = 'universal'
}else{
x@misc[['gene_krige_type']] = 'ordinary'
}
x@misc$sp_images
x@misc$platform
x@misc$transform
x@misc$gene_krige_type
# Specify resolution if not input by user
if(is.null(res)){
res = 0.5
}
x@misc[['gene_krige_res']] = res
# Give warning about kriging res < 0.5 for large matrices (e.g. Visium)
if(res < 0.5 & (nrow(x@coords[[1]]) > 1000)){
cat('Kriging at the requested resolution might take some time.\n')
}
# Give warning about kriging res < 0.5 for large matrices (e.g. Visium)
if(res < 0.5 & (nrow(x@spatial_meta[[1]]) > 1000)){
cat('Kriging at the requested resolution might take some time.\n')
}
res < 0.5 & (nrow(x@spatial_meta[[1]]) > 1000)
# Create lists to store prediction grids and borders.
if(is.null(x@misc[['krige_border']])){
x@misc[['krige_border']] = list()
x@misc[['gene_krige_grid']] = list()
for(k in length(x@tr_counts)){
x@misc[['krige_border']][[k]] = list()
x@misc[['gene_krige_grid']][[k]] = list()
}
}
python
# Generate combination of sample x gene to for.
combo = tibble::tibble()
i
subsetgenes_mask = genes %in% x@tr_counts[[i]]$gene
x@tr_counts[[i]
x@tr_counts[[i]]
subsetgenes_mask = genes %in% rownames(x@tr_counts[[i]])
subsetgenes = genes[subsetgenes_mask]
subsetgenes
combo = dplyr::bind_rows(combo, expand.grid(names(x@tr_counts)[i], subsetgenes))
combo
# Get genes not present.
notgenes = genes[!subsetgenes_mask]
if(!rlang::is_empty(notgenes)){
cat(paste(paste(notgenes, collapse=', '), ": Not present in the transformed counts for sample ", names(x@tr_counts[i]), ".\n"))
}
# Create concave hull to "cookie cut" border kriging surface.
x@misc[['krige_border']][[i]] = concaveman::concaveman(as.matrix(x@coords[[i]][c(3, 2)]))
head(x@spatial_meta$ST_mel1_rep1)
# Create concave hull to "cookie cut" border kriging surface.
x@misc[['krige_border']][[i]] = concaveman::concaveman(as.matrix(x@spatial_meta[[i]][, c('xpos', 'ypos')]))
x@misc[['krige_border']][[i]]
plot(x@misc[['krige_border']][[i]])
# Create grid for PyKrige or geoR.
if(python == T){
gridx = seq(min(x@spatial_meta[[i]][['xpos']]), max(x@spatial_meta[[i]][['xpos']]), res)
gridy = seq(min(x@spatial_meta[[i]][['ypos']]), max(x@spatial_meta[[i]][['ypos']]), res)
gridx = gridx[-length(gridx)]
gridy = gridy[-length(gridy)]
gene_geo_grid = expand.grid(
seq(min(gridx), max(gridx), by=res),
seq(min(gridy), max(gridy), by=res)
)
x@misc[['gene_krige_grid']][[i]] = gene_geo_grid
} else if(python == F && univ == F){ #  Create grid for geoR estimation.
gene_geo_grid <-expand.grid(
seq((min(x@coords[[i]][[3]])-1), (max(x@coords[[i]][[3]])+1), by=res),
seq((min(x@coords[[i]][[2]])-1), (max(x@coords[[i]][[2]])+1), by=res)
)
x@misc[['gene_krige_grid']][[i]] = gene_geo_grid
}
# Store prediction grid and kriging algorithm in STList.
if(python){
x@misc[['gene_krige_algorithm']] = 'pykrige'
} else{
x@misc[['gene_krige_algorithm']] = 'geor'
}
who
# Store decompressed transformed counts list in separate object
tr_counts = x@tr_counts
for(mtx in samples){
tr_counts[[mtx]] = expandSparse(x@tr_counts[[mtx]])
}
# Define cores available
cores = count_cores(nrow(combo))
# Loop through combinations of samples x genes
kriging_list = parallel::mclapply(seq_along(1:nrow(combo)), function(i_combo){
i = as.vector(unlist(combo[i_combo, 1]))
j = as.vector(unlist(combo[i_combo, 2]))
# Get transformed counts.
gene_expr = tr_counts[[i]][tr_counts[[i]]$gene == j, -1]
gene_expr = as.data.frame(t(gene_expr))
gene_expr = gene_expr %>%
tibble::rownames_to_column(., var="position")
# Match order of library names in counts data and coordinate data.
gene_expr = gene_expr[match(x@coords[[i]][[1]], gene_expr[[1]]), ]
gene_geo_df = cbind(x@coords[[i]][c(3, 2)], as.numeric(gene_expr[[2]]))
colnames(gene_geo_df)[3] = "gene_expr"
# Call the requested Kriging algorithm
if(python == T){
# Call PyKrige implementation.
gridx = seq(min(x@coords[[i]][[3]]), max(x@coords[[i]][[3]]), res)
gridy = seq(min(x@coords[[i]][[2]]), max(x@coords[[i]][[2]]), res)
gridx = gridx[-length(gridx)]
gridy = gridy[-length(gridy)]
kriging_res = krige_py(gridx=gridx, gridy=gridy, geo_df=gene_geo_df, univ=univ)
} else{
# Create geodata object from expression and coordinate data
gene_geo <- geoR::as.geodata(gene_geo_df, coords.col=c(1,2), data.col=3)
kriging_res = krige_geor(geodata=gene_geo, locations=x@misc[['gene_krige_grid']][[grep(i, names(x@tr_counts))]], univ=univ)
}
return(kriging_res)
}, mc.cores=cores, mc.preschedule=F)
kriging_list
# Loop through combinations of samples x genes
kriging_list = parallel::mclapply(seq_along(1:nrow(combo)), function(i_combo){
i = as.vector(unlist(combo[i_combo, 1]))
j = as.vector(unlist(combo[i_combo, 2]))
# Get transformed counts.
gene_expr = tr_counts[[i]][tr_counts[[i]]$gene == j, -1]
gene_expr = as.data.frame(t(gene_expr))
gene_expr = gene_expr %>%
tibble::rownames_to_column(., var="position")
# Match order of library names in counts data and coordinate data.
gene_expr = gene_expr[match(x@spatial_meta[[i]][[1]], gene_expr[[1]]), ]
gene_geo_df = cbind(x@spatial_meta[[i]][c('xpos', 'ypos')], as.numeric(gene_expr[[2]]))
colnames(gene_geo_df)[3] = "gene_expr"
# Call the requested Kriging algorithm
if(python == T){
# Call PyKrige implementation.
gridx = seq(min(x@spatial_meta[[i]][[3]]), max(x@spatial_meta[[i]][[3]]), res)
gridy = seq(min(x@spatial_meta[[i]][[2]]), max(x@spatial_meta[[i]][[2]]), res)
gridx = gridx[-length(gridx)]
gridy = gridy[-length(gridy)]
kriging_res = krige_py(gridx=gridx, gridy=gridy, geo_df=gene_geo_df, univ=univ)
} else{
# Create geodata object from expression and coordinate data
gene_geo <- geoR::as.geodata(gene_geo_df, coords.col=c(1,2), data.col=3)
kriging_res = krige_geor(geodata=gene_geo, locations=x@misc[['gene_krige_grid']][[grep(i, names(x@tr_counts))]], univ=univ)
}
return(kriging_res)
}, mc.cores=cores, mc.preschedule=F)
kriging_list
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/krige_helpers.R')
# Loop through combinations of samples x genes
kriging_list = parallel::mclapply(seq_along(1:nrow(combo)), function(i_combo){
i = as.vector(unlist(combo[i_combo, 1]))
j = as.vector(unlist(combo[i_combo, 2]))
# Get transformed counts.
gene_expr = tr_counts[[i]][tr_counts[[i]]$gene == j, -1]
gene_expr = as.data.frame(t(gene_expr))
gene_expr = gene_expr %>%
tibble::rownames_to_column(., var="position")
# Match order of library names in counts data and coordinate data.
gene_expr = gene_expr[match(x@spatial_meta[[i]][[1]], gene_expr[[1]]), ]
gene_geo_df = cbind(x@spatial_meta[[i]][c('xpos', 'ypos')], as.numeric(gene_expr[[2]]))
colnames(gene_geo_df)[3] = "gene_expr"
# Call the requested Kriging algorithm
if(python == T){
# Call PyKrige implementation.
gridx = seq(min(x@spatial_meta[[i]][[3]]), max(x@spatial_meta[[i]][[3]]), res)
gridy = seq(min(x@spatial_meta[[i]][[2]]), max(x@spatial_meta[[i]][[2]]), res)
gridx = gridx[-length(gridx)]
gridy = gridy[-length(gridy)]
kriging_res = krige_py(gridx=gridx, gridy=gridy, geo_df=gene_geo_df, univ=univ)
} else{
# Create geodata object from expression and coordinate data
gene_geo <- geoR::as.geodata(gene_geo_df, coords.col=c(1,2), data.col=3)
kriging_res = krige_geor(geodata=gene_geo, locations=x@misc[['gene_krige_grid']][[grep(i, names(x@tr_counts))]], univ=univ)
}
return(kriging_res)
}, mc.cores=cores, mc.preschedule=F)
kriging_list
gene_expr
i_combo
seq_along(1:nrow(combo)
seq_along(1:nrow(combo))
i_combo=1
i = as.vector(unlist(combo[i_combo, 1]))
j = as.vector(unlist(combo[i_combo, 2]))
i
j
# Get transformed counts.
gene_expr = tr_counts[[i]][tr_counts[[i]]$gene == j, -1]
gene_expr
# Get transformed counts.
gene_expr = tr_counts[[i]][tr_counts[[i]]$gene == j, -1]
gene_expr
View(gene_expr)
j
# Get transformed counts.
gene_expr = tr_counts[[i]][rownames(tr_counts[[i]]) == j, ]
gene_expr
# Loop through combinations of samples x genes
kriging_list = parallel::mclapply(seq_along(1:nrow(combo)), function(i_combo){
i = as.vector(unlist(combo[i_combo, 1]))
j = as.vector(unlist(combo[i_combo, 2]))
# Get transformed counts.
gene_expr = tr_counts[[i]][rownames(tr_counts[[i]]) == j, ]
gene_expr = as.data.frame(t(gene_expr))
gene_expr = gene_expr %>%
tibble::rownames_to_column(., var="position")
# Match order of library names in counts data and coordinate data.
gene_expr = gene_expr[match(x@spatial_meta[[i]][[1]], gene_expr[[1]]), ]
gene_geo_df = cbind(x@spatial_meta[[i]][c('xpos', 'ypos')], as.numeric(gene_expr[[2]]))
colnames(gene_geo_df)[3] = "gene_expr"
# Call the requested Kriging algorithm
if(python == T){
# Call PyKrige implementation.
gridx = seq(min(x@spatial_meta[[i]][[3]]), max(x@spatial_meta[[i]][[3]]), res)
gridy = seq(min(x@spatial_meta[[i]][[2]]), max(x@spatial_meta[[i]][[2]]), res)
gridx = gridx[-length(gridx)]
gridy = gridy[-length(gridy)]
kriging_res = krige_py(gridx=gridx, gridy=gridy, geo_df=gene_geo_df, univ=univ)
} else{
# Create geodata object from expression and coordinate data
gene_geo <- geoR::as.geodata(gene_geo_df, coords.col=c(1,2), data.col=3)
kriging_res = krige_geor(geodata=gene_geo, locations=x@misc[['gene_krige_grid']][[grep(i, names(x@tr_counts))]], univ=univ)
}
return(kriging_res)
}, mc.cores=cores, mc.preschedule=F)
kriging_list
names(kriging_list) = paste(combo[[1]], combo[[2]], sep='&&')
# Store kriging results in STList.
for(i in 1:nrow(combo)){
combo_name = unlist(strsplit(names(kriging_list)[i], split = '&&'))
x@gene_krige[[combo_name[2]]][[combo_name[1]]] = kriging_list[[i]]
}
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/gene_krige.R')
exampleSTList = gene_krige(exampleSTList)
x=exampleSTList
genes=NULL
plot_who=NULL
color_pal='YlOrBr'
image=F
visium=T
ptsize=0.5
require('magrittr')
require('ggplot2')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/plot_spatial.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/plot_helpers.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/classDefinitions.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/detect_input.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/STList.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/import_visium_h5.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/import_visium.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/utils.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/transform_data.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/gene_krige.R')
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/krige_helpers.R')
# Vector with several filepaths tsv, sample names (required).
rna_fp = c('/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel1_rep1_counts.tsv',
'/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel1_rep2_counts.tsv',
'/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel2_rep1_counts.tsv',
'/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel2_rep2_counts.tsv')
coord_fp = c('/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel1_rep1_mapping.tsv',
'/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel1_rep2_mapping.tsv',
'/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel2_rep1_mapping.tsv',
'/Users/4472525/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/inst/extdata/ST_mel2_rep2_mapping.tsv')
exampleSTList = STlist(rnacounts=rna_fp, spotcoords=coord_fp, samples=c('ST_mel1_rep1', 'ST_mel1_rep2', 'ST_mel2_rep1', 'ST_mel2_rep2'))
exampleSTList = transform_data(exampleSTList)
exampleSTList = gene_krige(exampleSTList)
x=exampleSTList
genes=NULL
plot_who=NULL
color_pal='YlOrBr'
image=F
visium=T
ptsize=0.5
# Option to use plotly disabled (not supporting geomPolypath)
inter=F
# Test that a gene name was entered.
if (is.null(genes)) {
stop("Please, enter one or more genes to plot.")
}
names(x@gene_krige)
x=exampleSTList
genes=c( "MS4A1","CD79A","CXCL13" )
plot_who=NULL
color_pal='YlOrBr'
image=F
visium=T
ptsize=0.5
# Option to use plotly disabled (not supporting geomPolypath)
inter=F
# Test that a gene name was entered.
if (is.null(genes)) {
stop("Please, enter one or more genes to plot.")
}
rm(plot_who)
samples=NULL
# Option to use plotly disabled (not supporting geomPolypath)
inter=F
# Test that a gene name was entered.
if (is.null(genes)) {
stop("Please, enter one or more genes to plot.")
}
# Test if no specific subject plot was requested.
if (is.null(sam)) {
plot_who <- c(1:length(x@counts))
}
# Test if no specific subject plot was requested.
if (is.null(samples)) {
samples <- c(1:length(x@counts))
}
i
i=1
# If genes='top', get names of 10 genes with the highest standard deviation.
if(length(genes) == 1 && genes == 'top'){
genes = c()
for(i in samples){
genes = append(genes, x@gene_meta[[i]][['gene']][order(x@gene_meta[[i]][['vst.variance.standardized']], decreasing=T)][1:top_n])
}
# Get unique genes from most variable.
genes = unique(genes)
}
genes
# If genes='top', get names of 10 genes with the highest standard deviation.
if(length(genes) == 1 && genes == 'top'){
genes = c()
for(i in samples){
# Find tops variable genes using Seurat approach. In the past, instead of Seurat, genes with the highest stdev were used
if(any(colnames(x@gene_meta[[i]]) == 'vst.variance.standardized')){
x@gene_meta[[i]] = x@gene_meta[[i]][, !grepl('vst.variance.standardized', colnames(x@gene_meta[[i]]))]
}
x@gene_meta[[i]] = Seurat::FindVariableFeatures(x@counts[[i]], verbose=F) %>%
tibble::rownames_to_column(var='gene') %>%
dplyr::select('gene', 'vst.variance.standardized') %>%
dplyr::left_join(x@gene_meta[[i]], ., by='gene')
genes = append(genes, x@gene_meta[[i]][['gene']][order(x@gene_meta[[i]][['vst.variance.standardized']], decreasing=T)][1:top_n])
}
# Get unique genes from most variable.
genes = unique(genes)
}
genes
# Store maximum and minimum expression value for plot color scaling
maxvalue <- c()
minvalue <- c()
for (i in samples) {
for (gene in genes) {
# Test if kriging exists for a gene and subject.
if (rlang::has_name(x@gene_krige, gene)){
if(length(x@gene_krige[[gene]]) >= i){
# Find maximum expression value for each spatial array.
values <- x@gene_krige[[gene]][[i]]
maxvalue <- append(maxvalue, max(values))
minvalue <- append(minvalue, min(values))
}
}
}
}
# Find maximum value among selected spatial arrays.
maxvalue <- max(maxvalue)
minvalue <- min(minvalue)
# Create list of plots.
kp_list <- list()
source('~/Dropbox (Moffitt Cancer Center)/SPATIAL_TRANSCRIPTOMICS/spatialGE/R/plot_gene_krige.R')
kp = plot_gene_krige(exampleSTList, c( "MS4A1","CD79A","CXCL13" ))
kp$MS4A1_1
plot_spatial(exampleSTList, samples=1, genes = "MS4A1")
devtools::load_all('../')
devtools::load_all('../')
