##
#' @title pseudobulk_plots: Generates a PCA and heatmap for "pseudo bulk" spatial samples
#' @description Aggregates counts and generates PCA  and heatmap plots of "pseudo bulk" counts
#' from spatial transcriptomics data.
#' @details
#' This function takes an STlist, and optionally the name of a clinical or sample-associated
#' metadata variable, performs PCA, and generates a heatmap of "pseudo bulk" counts from ST
#' data. The "pseudo bulk" counts are generated by summing all counts from all cell/spots for
#' each gene.
#'
#' @param x an STList.
#' @param plot_meta a string indicating the name of the variable in the sample metadata.
#' @param max_var_genes number of most variable genes (standard deviation) to use in PCA and heatmap
#' @param hm_display_genes number of genes to display in heatmap. Must be equal or lower than `max_var_genes`
#' @param color_pal a string of a color palette from khroma or RColorBrewer, or a
#' vector with colors with enough elements to plot categories.
#' @param ptsize the size of the points in the PCA plot. Passed to `size` aesthetic from `ggplot2`.
#'
#' @examples
#' # In this example, melanoma is an STlist.
#' # pseudobulk_plots(melanoma, samplemeta='gender')
#'
#' @export
#'
#' @import Matrix
#' @import ggplot2
#' @importFrom magrittr %>%
#' @importFrom methods as is new
#
#
pseudobulk_plots = function(x=NULL, plot_meta=NULL, max_var_genes=5000, hm_display_genes=30, color_pal="muted", ptsize=5) {

  #require('magrittr')
  #require('Matrix')
  #require('ggplot2')

  tr_method='log'

  if(!is.null(plot_meta) && !(plot_meta %in% colnames(x@sample_meta))){
    stop('Variable not in sample metadata. Verify that input matches variable name in sample data')
  }

  # Test if an STList has been input.
  if(is.null(x) | !is(x, 'STlist')){
    stop("The input must be an STList.")
  }

  # Stop function if only one sample provided.
  if(length(x@counts) < 3){
    stop('Refusing to make PCA and heatmap containing less than two samples!')
  }

  # Extract clinical/metadata from specified variable. If none specified, use the
  # array IDs from the first column of clinical data.
  # Also get labels for PCA points.
  if(!is.null(plot_meta)){
    clinvar_vals <- as.character(x@sample_meta[[plot_meta]])
    clinvar_vals <- tibble::tibble(!!plot_meta := clinvar_vals,
                                   sample_name=x@sample_meta[['samplename']]) %>%
      tibble::column_to_rownames('sample_name')
  } else{
    plot_meta <- 'ST_sample'
    clinvar_vals = names(x@counts)
    clinvar_vals <- tibble::tibble(ST_sample=clinvar_vals,
                                   sample_name=clinvar_vals) %>%
      tibble::column_to_rownames('sample_name')
  }

  # Create data frame to store "bulk counts".
  bulkcounts_df <- tibble::tibble(gene=rownames(x@counts[[1]]))

  # Loop through count matrices, get gene-wise sums, and collate samples
  for(i in names(x@counts)){
    expanded_mtx = expandSparse(x@counts[[i]])

    bulk_expr <- rowSums(expanded_mtx) %>%
      tibble::as_tibble_col(., column_name=i) %>%
      tibble::add_column(gene=rownames(x@counts[[i]]), .before=1)

    bulkcounts_df <- dplyr::inner_join(bulkcounts_df, bulk_expr, by='gene')
  }

  # Apply voom or log transform
  # if(tr_method == 'voom'){
  #   # Get normalization factors from the "bulk" libraries.
  #   norm_factors <- edgeR::calcNormFactors(bulkcounts_df[, -1], method='TMM', lib.size=NULL)
  #   # Create new object to store the size-corrected counts.
  #   normcounts_df <- c()
  #   # Divide each count value by their respective column (sample) normalization factor.
  #   for(raw_col in names(bulkcounts_df[, -1])){
  #     normcounts_df <- dplyr::bind_cols(normcounts_df, tibble::as_tibble(bulkcounts_df[raw_col] / norm_factors[raw_col]))
  #   }
  #   # Apply limma-voom to lib-size normalized "bulk" libraries.
  #   tr_df <- limma::voom(normcounts_df, design=NULL, lib.size=colSums(bulkcounts_df[, -1]), normalize.method='none', plot=F)
  #   # Put back gene names to matrix and store in object.
  #   tr_df = tibble::as_tibble(tr_df$E) %>%
  #     tibble::add_column(gene=bulkcounts_df[[1]], .before=1)
  # } else
    if(tr_method == 'log'){
    # Calculate (spot) library sizes. Then, add 1 to each library size.
    libsizes = colSums(bulkcounts_df[, -1])
    # Check that there are not zero-count spots
    if(any(libsizes == 0)){
      stop('Please, remove samples containing zero reads...')
    }
    # Divide each count value by their respective column (spot) normalization factor.
    normcounts_df = sweep(bulkcounts_df[, -1], 2, libsizes, '/')
    # Then multiply by scaling factor
    # df = df * scale_f
    # Apply log transformation to count data.
    tr_df = log1p(normcounts_df * 100000)
    # Put back gene names to matrix and store in object.
    tr_df = tibble::as_tibble(tr_df) %>%
      tibble::add_column(gene=bulkcounts_df[[1]], .before=1) %>%
      tibble::column_to_rownames('gene')
    }

  # Turn transformed counts to a transposed matrix.
  tr_df <- t(as.matrix(tr_df))
  # Get variable genes and subset
  vargenes = sort(apply(tr_df, 2, sd), decreasing=T)
  tr_df = tr_df[, match(names(vargenes[1:max_var_genes]), colnames(tr_df))]
  tr_df = scale(tr_df)

  pca_p = pseudobulk_pca(scaled_mtx=tr_df, color_pal=color_pal, meta_df=clinvar_vals,
                         meta_name=plot_meta, ptsize=ptsize)

  hm_p = pseudobulk_heatmap(scaled_mtx=tr_df, color_pal=color_pal, meta_df=clinvar_vals,
                            meta_name=plot_meta, hm_display_genes=hm_display_genes)

  return(list(pca=pca_p,
              heatmap=hm_p))
}


# Helpers ----------------------------------------------------------------------

##
# @title pseudobulk_pca
#
# @param scaled_mtx a gene-scaled expression matrix
# @param meta_df data frame with containing the sample-level annotations
# @return meta_name name of variable in `meta_df` to plot
#
#
pseudobulk_pca = function(scaled_mtx=NULL, color_pal=NULL, meta_df=NULL, meta_name=NULL, ptsize=NULL){
  # Perform PCA on transposed matrix.
  pca_expr <- prcomp(scaled_mtx, scale=F)
  # Get PCA coordinates and add clinical variable data.
  pca_tbl <- tibble::as_tibble(pca_expr$x)
  pca_tbl <- pca_tbl %>%
    tibble::add_column(meta_df, .before=1)
  # Get number of categories from selected variable.
  n_cats <- nlevels(as.factor(pca_tbl[[meta_name]]))
  # Create color palette.
  cat_cols = color_parse(color_pal, n_cats=n_cats)
  # Associate colors with categories.
  names(cat_cols) <- levels(as.factor(pca_tbl[[meta_name]]))
  # Define shapes of points according to clinical variable.
  cat_shapes <- (16:25)[1:n_cats]
  names(cat_shapes) <- levels(as.factor(pca_tbl[[meta_name]]))
  # Make plot
  pca_tbl = pca_tbl %>% tibble::rownames_to_column('pca_labs')
  pca_p = ggplot(pca_tbl) +
    geom_point(aes(x=PC1, y=PC2, shape=get(meta_name), color=get(meta_name)), size=ptsize) +
    ggrepel::geom_text_repel(aes(x=PC1, y=PC2, label=pca_labs)) +
    scale_color_manual(meta_name, values=cat_cols) +
    scale_shape_manual(meta_name, values=cat_shapes) +
    ggtitle('PCA of "pseudobulk" samples') +
    coord_fixed() +
    theme_bw()

  return(pca_p)
}


##
# @title pseudobulk_heatmap
#
# @param scaled_mtx a gene-scaled expression matrix
# @param meta_df data frame with containing the sample-level annotations
# @return meta_name name of variable in `meta_df` to plot
#
#
pseudobulk_heatmap = function(scaled_mtx=NULL, color_pal=NULL, meta_df=NULL, meta_name=NULL, hm_display_genes=NULL){
  # Get number of categories from selected variable.
  n_cats = nlevels(as.factor(meta_df[[meta_name]]))
  # Create color palette.
  cat_cols = color_parse(color_pal, n_cats=n_cats)
  # Associate colors with categories.
  names(cat_cols) = levels(as.factor(meta_df[[meta_name]]))
  # Make list to use in heatmap annotation
  cat_cols = list(cat_cols)
  names(cat_cols) = meta_name

  # Create annotation object for ComplexHeatmap
  hm_ann = ComplexHeatmap::HeatmapAnnotation(df=meta_df, col=cat_cols)

  # Order samples according to annotation and subset genes
  hm_mtx = t(scaled_mtx)
  hm_mtx = hm_mtx[, match(rownames(meta_df), colnames(hm_mtx))]
  hm_mtx = hm_mtx[1:hm_display_genes, ]
  # Make heatmap
  hm_p = ComplexHeatmap::Heatmap(hm_mtx, show_row_dend=F,
                                 top_annotation=hm_ann,
                                 column_names_rot=30,
                                 heatmap_legend_param=list(title="Scaled mean\nexpression"),
                                 row_names_gp=grid::gpar(fontsize=8),
                                 show_column_names=F, column_title='Aggregated gene expression\n("pseudobulk")')

  hm_p = ComplexHeatmap::draw(hm_p, merge_legend=T)

  return(hm_p)
}

