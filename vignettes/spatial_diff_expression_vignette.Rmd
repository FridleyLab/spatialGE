---
title: "Differential gene expression accounting for spatial dependency (melanoma data set from Thrane et al. 2018)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{spatialge_tutorial_stde}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r vig_settings, include = FALSE}
knitr::opts_chunk$set(
  collapse=TRUE,
  comment="#>",
  fig.width=10, fig.height=7
)
```

In most spatial transcriptomics (ST) data sets, gene expression is measured in locations (spots or cells) that are separated by a certain fixed or variable distance. Depending on the scale at which the tissue sample is assayed, cells or spots that are close are more likely to be similar compared to distant cells or spots that. This correlation between (transcriptomic) similarity and spatial distance is known as spatial dependency. In `spatialGE,` analysis of differential gene expression is performed using linear models with spatial covariance structures.

For *non-spatial* differential expression analysis, the expression $y(s_i)$ of a gene in spot/cell $i$ is described as:

$$
y(s_i) = μ + ε(s_i)
$$ where $μ$ is the average expression of the gene and $ε(s_i)$ is the random error at spot/cell $i$. To dissect the variance defined by the spatial closeness of spots/cells, the model can be expanded as:

$$
Y(s_i) = μ + w(s_i) + ε(s_i) 
$$

where $w(s_i)$ denotes the spatial effect or spatial dependency of spot/cell $i$. In `spatialGE`, the $w(s_i)$ component is defined by a exponential or spherical covariance structure. This analysis has been implemented in the function `STde`

## Differential gene expression between tumor niches in melanoma stage III tumor biopsies

The detection of differentially expressed genes using spatial covariance structures provides more statistical power, however, it is computationally expensive. This higher use of computational resources is more evident in ST data that contains thousands of spots/cells. For convenience, we guide the reader through the use of `STde` on the smaller ST data set generated by [Thrane et al. (2018)](https:doi.org/10.1158/0008-5472.CAN-18-0747). This data set includes lymph node biopsies from four patients with stage III melanoma, with two tissue slices per biopsy. This technology is a predecessor of the Visium assay, and allowed RNA capture in up to 1,007 "spots" separated each other by 200μM. The spots are 100μM in diameter, which corresponds to 5-40 cells according to the authors. The data set is included in the `spatialGE` repository, but users can also find the data in the [authors' website](https://www.spatialresearch.org/resources-published-datasets/doi-10-1158-0008-5472-can-18-0747/).

## Creating an STlist (Spatial Transcriptomics List)

In spatialGE, ST data can be input in many formats. The reader is encouraged to see the `STlist` reference (see [here](https://fridleylab.github.io/spatialGE/reference/STList.html) to learn about the different options to read ST data in `spatialGE`. In this guide, we provide the `STlist` function with comma-delimited files containing gene expression counts per spot and comma-delimited containing the spatial coordinates per spot.

The example files in this tutorial can be downloaded from the [GitHub repository](https://github.com/FridleyLab/spatialGEdev/tree/main/inst/extdata). They can be accessed directly from R like so:

```{r data_fpaths1}
data_files <- system.file("extdata/melanoma_thrane", package="spatialGE")
count_files <- list.files(data_files, full.names=T, pattern='counts')
coord_files <- list.files(data_files, full.names=T, pattern='mapping')
```

This melanoma ST data set also contains sample-level meta data. We will also provide this file to specify sample names:

```{r data_fpaths2}
clin_file <- list.files(data_files, full.names=T, pattern='clinical')
```

Load spatialGE:

```{r load_spatialge, message=F, warning=F}
library('spatialGE')
#devtools::load_all('../')
```

We can load the files into an STlist object with:

```{r create_stlist, warning=F}
melanoma <- STlist(rnacounts=count_files, spotcoords=coord_files, samples=clin_file)
```

*Note*: If you receive a warning indicating that an input file has a incomplete final line, you can ignore it. Alternatively, modify the input files with a text editor by adding an empty line at the end of the files.

The `melanoma` object is an STlist that contains the count data, spot coordinates, and clinical meta data.

```{r call_stlist}
melanoma
```

In order to perform differential gene expression analysis, the data needs to be
transformed. Transformation of the gene expression data is achieved with:

```{r norm_chunk}
melanoma <- transform_data(melanoma)
```

## A brief demonstartion of the spatial dependency in spatial transcriptomics data

Before we jump into testing for differentially expressed genes, let us look at
how gene expression changes with respect to the spatial distance between spots/cells.
We can look at this spatial depedency by using semiovariogram analysis, a technique
used in spatial statistics.

`spatialGE` uses parameters estimated from the semiovariogram to model the spatial
covariance, however `spatialGE` does not have functions for visualization of 
semiovariograms. Hence, we will generate the semiovariogram by using some data 
manipulation with `tidyverse` and `geoR`. We will also load `ggrepel` for some of
the visualizations:

```{r tidy_chunk, message=F, warning=F}
library('tidyverse')
library('geoR')
library('ggrepel')
```

We will model the expression of the gene _MLANA_ for sample ST_mel1_rep1. The gene
_MLANA_ is highly expressed by melanoma cells, and we will examine how its expression
varies with respect to the distance between points within the sample.

```{r variogram_chunk}
# Sample and gene to be used in example
samplename = 'ST_mel1_rep1'
gene = 'MLANA'
# Prepare data with coordinate and expression data
# Add dummy grouping variable (necessary as grouping variable in the package nlme)
df_vgm = melanoma@spatial_meta[[samplename]] %>%
  select(libname, xpos, ypos) %>%
  left_join(., tibble(libname=colnames(melanoma@tr_counts[[samplename]]),
                      geneexpr = as.vector(melanoma@tr_counts[[samplename]][gene, ])), by='libname') %>%
  add_column(dummycol=1) %>%
  column_to_rownames(var='libname')
```

The data frame created with the previous commands contains the spatial coordinates of
each spot (`xpos`, `ypos`) and transformed expression of _MLANA_ (`geneexpr`).

```{r vgmdf_chunk}
head(df_vgm)
```

Next, we calculate the empirical semiovariogram. In a semiovariogram, each point 
describes the variance in gene expression (semiovariance) with respect to the 
distance between two spots/cells. If spatial dependency is present, we should see
a trend towards higher smiovariance as distance increases. In other words, variance
between close spots is lower than variance between distant spots.

```{r vgm_chunk, fig.asp=1, fig.width=2}
# Create geodata object
geodata_obj = geoR::as.geodata(df_vgm, coords.col=c('xpos', 'ypos'), data.col='geneexpr')
# Calculate empirical variogram
emp_vgm = geoR::variog(geodata_obj, uvec=100, trend='cte')

plot(emp_vgm, pch=16, cex=0.5)
text(c(2, 5, 14.5), c(0.6, 1.65, 0.6), 
     labels=c('nugget','sill', 'range'),
     col=c('purple', 'green', 'goldenrod1'))
clip(x1=-1, x2=12, y1=-1, y2=1.6)
abline(h=1.5, col='green', lwd=3, lty=2)
clip(x1=-1, x2=1, y1=-1, y2=1.5)
abline(h=0.75, col='purple', lwd=3, lty=2)
clip(x1=-1, x2=12.1, y1=-1, y2=1.5)
abline(v=12, col='goldenrod1', lwd=3, lty=2)
```

We can see that semiovariance is higher at longer distances. Note however, that
this relationship is disrupted at much longer spot-to-spot distances (> 20 in this 
case). This disruption occurs because as distances between spots are larger, some
spots may belong to distant tissue niches that hold similarity. Still, the association
holds for most of the range, hence, we can fit different spatial models to describe
the variation.

In this case, we will use the package `nlme` to estimate parameters (nugget, sill,
and range) for exponential, spherical, and gaussian correlation structures using
the _MLANA_ gene expression. Note we use the set the argument `value=12`, to indicate 
that the range of this semiovariogram is roughly placed at a distance of 12. The 
range parameter indicates the distance at which the spot-to-spot variance is no 
longer correlated with distance.

```{r lme_chunk}
# Create null model
null_mod = nlme::lme(fixed=geneexpr ~ 1, data=df_vgm, random = ~ 1 | dummycol)

# Define correlation structures
exp_covstr = nlme::corExp(form = ~ xpos + ypos, nugget=T, metric='euclidean', value=12)
sph_covstr = nlme::corSpher(form = ~ xpos + ypos, nugget=T, metric='euclidean', value=12)
gau_covstr = nlme::corGaus(form = ~ xpos + ypos, nugget=T, metric='euclidean', value=12)

exp_mod = update(null_mod, correlation=exp_covstr, method="REML")
sph_mod = update(null_mod, correlation=sph_covstr, method="REML")
gau_mod = update(null_mod, correlation=gau_covstr, method="REML")
```

We then use the estimated parameters to fit the models to the empirical variogram.

```{r vgmplot_chunk1, message=F, fig.asp=1, fig.width=2}
exp_vgm = geoR::variofit(emp_vgm, fix.nugget=T, cov.model='exponential',
                         ini.cov.pars=c(exp_mod$sigma^2,
                                        exp_mod$modelStruct$corStruct[1]),
                         nugget=exp_mod$modelStruct$corStruct[2],
                         wei="equal")
sph_vgm = geoR::variofit(emp_vgm, fix.nugget=T, cov.model='spherical',
                         ini.cov.pars=c(sph_mod$sigma^2,
                                        sph_mod$modelStruct$corStruct[1]),
                         nugget=sph_mod$modelStruct$corStruct[2],
                         wei="equal")
gau_vgm = geoR::variofit(emp_vgm, fix.nugget=T, cov.model='gaussian',
                         ini.cov.pars=c(gau_mod$sigma^2,
                                        gau_mod$modelStruct$corStruct[1]),
                         nugget=gau_mod$modelStruct$corStruct[2],
                         wei="equal")

plot(emp_vgm, pch=16, cex=0.5)
lines(exp_vgm, col='red', lwd=3)
lines(sph_vgm, col='blue', lwd=3)
lines(gau_vgm, col='orange', lwd=3)
```

All of the models (exponential, spherical, and gaussian) fit well the semiovariogram,
however, in `spatialGE` we have implemented only the exponential and spherical 
covariance structures. In our development of STde, we have seen that those two
models fit a variety of gene expression patterns.

## Detection of tissue niches with `STclust`

Now that we have explored the effect of spatial dependency on gene expression using 
semiovariograms, we can continue with the `spatialGE` pipeline to test for differentially
expressed genes. We start by detecting tissue niches via clustering with `STclust`.

We will use a spatial weight of 0.025 for this analysis and cluster definition by
dynamicTreeClusters (`ks='dtc'`). For more details on the `STclust` algorithm,
please refer to the documentation or our [technical article](https://doi.org/10.1093/bioinformatics/btac145).

```{r clustespots_chunk}
melanoma <- STclust(melanoma, 
                    ks='dtc', 
                    ws=0.025)
```

Results of clustering can be plotted via the `STplot()` function:

```{r plotclustspots_chunk, fig.align='center'}
cluster_p <- STplot(melanoma, 
                    samples='ST_mel1_rep1', 
                    ws=0.025,
                    visium=F, 
                    ptsize=2)

print(cluster_p[[1]])
```

By comparison with results from then [study that generated this dataset](https:doi.org/10.1158/0008-5472.CAN-18-0747),  
we can say that the blue cluster corresponds to a immune infiltrated area, the 
yellow cluster to the melanoma region, and red a stromal region.

With clusters identified, we can run the `STde` function. We test de genes on the 
100 genes with the highest variation (as defined by `Seurat`'s function `FindVariableFeatures`).

```{r stde_chunk}
deg = STde(melanoma, samples='ST_mel1_rep1', w=0.025, ks='dtc', topgenes=1000)
```

The output of `STde` is a list, where each element of the list is a data frame containing
the test results for each sample:

```{r stde_res1}
print(deg$ST_mel1_rep1)
```

The columns `p_val` and `adj_p_val` are respectively the nominal and adjusted p-values
resulting from the differential expression tests using the _non-spatial_ models 
(i.e., the traditional approach). The `sph_p_val`, `sph_adj_pval`, `exp_p_val`, and 
`exp_adj_p_val` are the p-values resulting from fitting the _spherical_ and 
_exponential_ covariance structures.

We can look at the -log10(p-values) to compare each spatial model to the non-spatial
model:

```{r compare_pval, warning=F}
log_pval = deg$ST_mel1_rep1 %>%
  select(gene, cluster, p_val, sph_p_val, exp_p_val) %>%
  mutate(log_p_val= -log10(p_val+1e-100)) %>%
  mutate(log_sph_p_val= -log10(sph_p_val+1e-100)) %>%
  mutate(log_exp_p_val= -log10(exp_p_val+1e-100))

p1 = ggplot(log_pval, aes(x=log_p_val, y=log_sph_p_val)) +
  geom_abline(intercept=0, slope=1, linetype="dashed", color='red') +
  geom_hline(yintercept=-log10(0.05), linetype="dashed") +
  geom_point(aes(color=cluster)) +
  geom_text_repel(aes(label=gene), size=2, show.legend=F) +
  scale_color_manual(values=c('lightcoral', 'gold', 'cornflowerblue'))

p2 = ggplot(log_pval, aes(x=log_p_val, y=log_exp_p_val)) +
  geom_abline(intercept=0, slope=1, linetype="dashed", color='red') +
  geom_hline(yintercept=-log10(0.05), linetype="dashed") +
  geom_point(aes(color=cluster)) +
  geom_text_repel(aes(label=gene), size=2, show.legend=F) +
  scale_color_manual(values=c('lightcoral', 'gold', 'cornflowerblue'))

```

```{r compare_pval_p, warning=F}
p1 + p2
```

We can see that when comparing the non-spatial models to the spatial models, the 
non-spatial model tended to provide more significant p-values (i.e., higher 
-log10(p-values), or below the 1:1 red dotted line). This pattern is suggestive of 
type I error inflation when the spatial dependency is not considered. In the case of
the gene _DCN_, the non-spatial model detected it as differentially expressed in 
cluster 1 (stroma), but the spatial models showed that this gene was not differentially
expressed in cluster 1 (below the -log10(0.05) black dotted line).

The `STde` function also outputs the Akaike (AIC) andBayesian (BIC) information criterion to 
help users evaluate which model was better supported compared to the non-spatial 
models. An easy way to summarize which model fitted the data better is to compare the 
BICs (or AICs) using scatterplots.

```{r bic_scatter, warning=F, fig.asp=0.8, fig.width=2}
deg$ST_mel1_rep1 %>%
  select(gene, sph_bic, exp_bic) %>%
  ggplot(aes(x=sph_bic, y=exp_bic)) +
  geom_abline(intercept=0, slope=1, linetype="dashed", color='red') +
  geom_point(size=0.5) +
  geom_text_repel(aes(label=gene), size=2, show.legend=F)
```

The graph above shows the comparison of the BICs obtained for each test using either
the exponential or spherical models. We can see that both models showed similar 
fit, as most tests (i.e. points) fall on the 1:1 red dotted line. There are however a
few genes ( _PEG10_, _CD19_, _CD37_, _DLL3_) for which the exponential model yielded 
lower BICs than the spherical model. For those tests, the exponential model presented a 
better fit compared to the spherical model.

Finally, we'll use `spatialGE` plotting capabilities (`STplot`) to create gene
expression surfaces for the DE gene with highest logFC in each cluster. Note that we filter
out the p-values coded as "-9999", as those represent cases where the spatial models
could not be completed due to non maximum likelihood convergence.

```{r degenes_subset, message=F}
# Subset DE genes based on adjusted p-value (from exponential model) and average logFC
exp_deg = deg$ST_mel1_rep1 %>%
  select(gene, cluster, avc_log2fc, exp_adj_p_val) %>%
  filter(exp_adj_p_val < 0.05 & exp_adj_p_val != -9999) %>%
  group_by(cluster) %>%
  slice_max(order_by=avc_log2fc, n=1)

# Create gene expression surfaces
melanoma = gene_interpolation(melanoma, genes=exp_deg[['gene']], samples='ST_mel1_rep1')
p3 = STplot_interpolation(melanoma, genes=exp_deg[['gene']], samples='ST_mel1_rep1')
```

```{r degenes_plots, fig.height=2, fig.width=5}
ggpubr::ggarrange(plotlist=p3, ncol=3, nrow=1)
```

<details>

<summary>**Session Info**</summary>

```{r}
sessionInfo()
```

</details>
